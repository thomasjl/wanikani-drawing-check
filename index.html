
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kanji Write Check ‚Äî WaniKani (v2)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", Arial, sans-serif; margin: 2rem; }
    header { display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-end; }
    input[type="text"], select { padding:.5rem; font-size:1rem; }
    button { padding:.6rem 1rem; font-size:1rem; margin-right:.5rem; cursor:pointer; }
    .card { border:1px solid #8883; border-radius:12px; padding:1rem; margin-top:1rem; }
    .label { font-size:.9rem; color:#666; }
    .meaning { font-size:1.4rem; }
    .kanji { font-size:4rem; line-height:1.2; margin-top:.25rem; display:none; }
    .readings { font-size:1rem; color:#555; display:none; }
    .controls { margin-top:1rem; }
    .stats { margin-top:.75rem; color:#444; }
    .hint { font-size:.85rem; color:#666; margin-top:.5rem; }
    .error { color:#b00020; white-space:pre-wrap; }
    details { margin-top:1rem; }
    summary { cursor:pointer; }
    .diag-grid { display:grid; grid-template-columns: 220px 1fr; gap:.25rem .75rem; }
    .diag-grid div:nth-child(odd) { color:#666; }
    code { background:#0001; padding:.05rem .25rem; border-radius:4px; }
  </style>
</head>
<body>
<header>
  <div>
    <div class="label">Token WaniKani (lecture seule)</div>
    <!-- MODE "EN CLAIR" : pour pr√©remplir le token en dur, d√©commente la ligne suivante :
    <input id="token" type="text" size="48" value="09c154e9-8a05-4c21-a1f2-6196196c1be1" />
    -->
    <input id="token" type="text" size="48" placeholder="wk_..." />
    <button id="saveToken">Enregistrer (cookie)</button>
    <button id="clearToken">Effacer le cookie</button>
  </div>
  <div>
    <div class="label">S√©lection</div>
    <select id="mode">
      <option value="now">Kanji √† r√©viser maintenant</option>
      <option value="unlocked">Tous les kanji d√©bloqu√©s (non br√ªl√©s)</option>
      <option value="level">Kanji d‚Äôun niveau pr√©cis‚Ä¶</option>
    </select>
    <input id="level" type="number" min="1" max="60" placeholder="lvl" style="width:5rem; display:none;" />
    <button id="load">Charger</button>
  </div>
</header>

<div id="status" class="hint"></div>
<div id="error" class="error"></div>

<div id="card" class="card" hidden>
  <div class="label">Sens (anglais)</div>
  <div id="meaning" class="meaning"></div>

  <div id="kanji" class="kanji" lang="ja"></div>
  <div id="readings" class="readings"></div>

  <div class="controls">
    <button id="show">Afficher le kanji</button>
    <button id="success">J‚Äôai r√©ussi ‚úçÔ∏è</button>
    <button id="fail">Je me suis tromp√©</button>
    <button id="next">Suivant ‚ñ∂Ô∏é</button>
  </div>
  <div id="stats" class="stats"></div>
</div>

<details id="diagnostics">
  <summary>üîé Diagnostics (headers & requ√™tes)</summary>
  <div class="diag-grid" id="diag-grid">
    <div>Derni√®re URL :</div><div id="diag-url">‚Äî</div>
    <div>HTTP Status :</div><div id="diag-status">‚Äî</div>
    <div>RateLimit-Limit :</div><div id="diag-limit">‚Äî</div>
    <div>RateLimit-Remaining :</div><div id="diag-remaining">‚Äî</div>
    <div>RateLimit-Reset (epoch s) :</div><div id="diag-reset">‚Äî</div>
    <div>Last-Modified :</div><div id="diag-last">‚Äî</div>
    <div>ETag :</div><div id="diag-etag">‚Äî</div>
  </div>
</details>

<footer class="hint">
  Conseils : dessine sur papier, puis <b>affiche</b> le kanji pour te corriger.
  API : <code>Authorization: Bearer &lt;token&gt;</code> et <code>Wanikani-Revision: 20170710</code>.
</footer>

<script>
(() => {
  // ==== Constantes API (doc officielle 20170710) ====
  const API = 'https://api.wanikani.com/v2';
  const REVISION = '20170710';

  // ==== √âtat ====
  const state = {
    queue: [],
    index: 0,
    ok: 0,
    ko: 0,
    cache: JSON.parse(localStorage.getItem('wk_subject_cache') || '{}'),
    lastHeaders: {},
    lastUrl: '',
    lastStatus: ''
  };

  // ==== Helpers DOM/UI ====
  const $ = (sel) => document.querySelector(sel);
  function info(msg) { const s = $('#status'); if (s) s.textContent = msg; }
  function showError(err) {
    const e = $('#error');
    const msg = (typeof err === 'string') ? err : (err?.message || 'Erreur inconnue');
    if (e) e.textContent = msg;
  }
  function resetUI() {
    const e = $('#error'), s = $('#status'), card = $('#card'), k = $('#kanji'), r = $('#readings');
    if (e) e.textContent = '';
    if (s) s.textContent = '';
    if (card) card.hidden = true;
    if (k) k.style.display = 'none';
    if (r) r.style.display = 'none';
    state.ok = 0; state.ko = 0; updateStats();
  }
  function must(selector) {
    const el = $(selector);
    if (!el) {
      console.error(`[Init] √âl√©ment ${selector} introuvable.`);
      showError(`√âl√©ment manquant: ${selector}. V√©rifie l'ID dans le HTML.`);
      throw new Error(`Missing element: ${selector}`);
    }
    return el;
  }

  // ==== Cookies (token) ====
  // NOTE: En statique, on ne peut pas mettre HttpOnly. On mettra Secure + SameSite=Lax, et un max-age long.
  function setTokenCookie(token) {
    const maxAge = 60 * 60 * 24 * 365; // 1 an
    // Cookie attribu√© au chemin racine ; 'Secure' n√©cessite HTTPS
    document.cookie = `wk_token=${encodeURIComponent(token)}; Max-Age=${maxAge}; Path=/; SameSite=Lax; Secure`;
  }
  function getTokenCookie() {
    const m = document.cookie.match(/(?:^|; )wk_token=([^;]*)/);
    return m ? decodeURIComponent(m[1]) : '';
  }
  function clearTokenCookie() {
    document.cookie = `wk_token=; Max-Age=0; Path=/; SameSite=Lax; Secure`;
  }

  // ==== Token (priorit√© : cookie > input > localStorage pour compat ascendante) ====
  function getToken(tokenInput) {
    const fromCookie = getTokenCookie();
    const fromInput = (tokenInput.value || '').trim();
    const fromLS = (localStorage.getItem('wk_token') || '').trim();
    const t = (fromCookie || fromInput || fromLS).trim();
    if (!t) throw new Error('‚ö†Ô∏è Token requis. Colle ton token WaniKani (lecture seule) puis ‚ÄúEnregistrer (cookie)‚Äù.');
    return t;
  }

  // ==== Diagnostics headers ====
  function updateDiagnostics(url, res) {
    state.lastUrl = url;
    state.lastStatus = `${res.status} ${res.statusText}`;
    state.lastHeaders = {
      limit: res.headers.get('RateLimit-Limit'),
      remaining: res.headers.get('RateLimit-Remaining'),
      reset: res.headers.get('RateLimit-Reset'),
      etag: res.headers.get('ETag'),
      last: res.headers.get('Last-Modified')
    };
    const set = (id, v) => { const n = $(id); if (n) n.textContent = v || '‚Äî'; };
    set('#diag-url', state.lastUrl);
    set('#diag-status', state.lastStatus);
    set('#diag-limit', state.lastHeaders.limit);
    set('#diag-remaining', state.lastHeaders.remaining);
    set('#diag-reset', state.lastHeaders.reset);
    set('#diag-etag', state.lastHeaders.etag);
    set('#diag-last', state.lastHeaders.last);
  }

  // ==== Fetch JSON avec gestion 429 / erreurs d√©taill√©es ====
  async function fetchJson(url, token) {
    const res = await fetch(url, {
      headers: { 'Authorization': `Bearer ${token}`, 'Wanikani-Revision': REVISION }
    });
    updateDiagnostics(url, res);

    if (res.status === 429) {
      const reset = Number(res.headers.get('RateLimit-Reset')) || 0;
      const now = Math.floor(Date.now()/1000);
      const waitMs = Math.max((reset - now), 3) * 1000;
      info(`‚è≥ Rate limit atteint, attente ${Math.round(waitMs/1000)}s‚Ä¶`);
      await new Promise(r => setTimeout(r, waitMs));
      return fetchJson(url, token);
    }

    if (!res.ok) {
      let bodyText = '';
      try { bodyText = await res.text(); } catch {}
      let msg = `HTTP ${res.status} ‚Äî ${res.statusText}`;
      if (bodyText) {
        try {
          const j = JSON.parse(bodyText);
          if (j.error) msg = `HTTP ${res.status} ‚Äî ${j.error}`;
        } catch { msg = `HTTP ${res.status} ‚Äî ${bodyText}`; }
      }
      throw new Error(msg);
    }
    return res.json();
  }

  // ==== R√©cup√©ration assignments selon le mode ====
  async function fetchAssignments(token, modeSelect, levelInput) {
    const mode = modeSelect.value;
    let qs = `subject_types=kanji&hidden=false`;
    if (mode === 'now') {
      const now = new Date().toISOString();
      qs += `&available_before=${encodeURIComponent(now)}`;
      info('Chargement des kanji ‚Äúdus‚Äù maintenant‚Ä¶');
    } else if (mode === 'unlocked') {
      qs += `&unlocked=true&burned=false`;
      info('Chargement des kanji d√©bloqu√©s (non br√ªl√©s)‚Ä¶');
    } else {
      const lvl = Number((levelInput && levelInput.value) || 0);
      if (!lvl || lvl<1 || lvl>60) throw new Error('Sp√©cifie un niveau entre 1 et 60.');
      qs += `&levels=${lvl}&unlocked=true&burned=false`;
      info(`Chargement des kanji du niveau ${lvl}‚Ä¶`);
    }
    const url = `${API}/assignments?${qs}`;
    const first = await fetchJson(url, token);
    let items = first.data || [];
    let next = first.pages?.next_url;
    while (next) {
      const page = await fetchJson(next, token);
      items = items.concat(page.data || []);
      next = page.pages?.next_url;
    }
    return items;
  }

  // ==== R√©cup√©ration subjects (characters/meanings) en lots ====
  async function fetchSubjects(ids, token) {
    const unique = Array.from(new Set(ids));
    const subjects = [];
    const chunkSize = 950; // /subjects : jusqu'√† 1000/page (on reste en dessous)
    for (let i=0; i<unique.length; i+=chunkSize) {
      const chunk = unique.slice(i, i+chunkSize);
      const url = `${API}/subjects?ids=${chunk.join(',')}`;
      try {
        const json = await fetchJson(url, token);
        subjects.push(...(json.data || []));
        let next = json.pages?.next_url;
        while (next) {
          const page = await fetchJson(next, token);
          subjects.push(...(page.data || []));
          next = page.pages?.next_url;
        }
      } catch (e) {
        console.warn('Bulk /subjects?ids=‚Ä¶ a √©chou√©. Fallback /subjects/{id}', e);
        for (const id of chunk) {
          if (state.cache[id]) { subjects.push(state.cache[id]); continue; }
          const single = await fetchJson(`${API}/subjects/${id}`, token);
          const normalized = single.data ? single : { data: single };
          state.cache[id] = normalized;
          subjects.push(normalized);
        }
        localStorage.setItem('wk_subject_cache', JSON.stringify(state.cache));
      }
    }
    return subjects.filter(s => (s.data?.object || s.object) === 'kanji' || s.data?.characters);
  }

  // ==== Construire la file et afficher ====
  function buildQueue(subjects) {
    const items = subjects.map(s => {
      const d = s.data || s;
      const primary = (d.meanings || []).find(m => m.primary)?.meaning
                   || (d.meanings || [])[0]?.meaning || '(meaning unavailable)';
      const readings = (d.readings || []).map(r => `${r.type}: ${r.reading}`);
      return { id: d.id || s.id, characters: d.characters, meaning: primary, allMeanings: d.meanings, readings };
    }).filter(x => x.characters);
    for (let i = items.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [items[i], items[j]] = [items[j], items[i]];
    }
    state.queue = items;
  }

  function renderCard() {
    const card = $('#card');
    if (!state.queue.length) { info('Rien √† afficher.'); if (card) card.hidden = true; return; }
    const item = state.queue[state.index % state.queue.length];
    const meaning = $('#meaning'); const kanji = $('#kanji'); const readings = $('#readings');
    if (meaning) meaning.textContent = item.meaning + (item.allMeanings?.length>1 ? ` (${item.allMeanings.slice(1).map(m=>m.meaning).join(', ')})` : '');
    if (kanji) { kanji.textContent = item.characters; kanji.style.display = 'none'; }
    if (readings) { readings.textContent = item.readings.join(' ‚Ä¢ '); readings.style.display = 'none'; }
    if (card) card.hidden = false;
    updateStats();
  }

  function nextCard() { state.index = (state.index + 1) % state.queue.length; renderCard(); }
  function updateStats() {
    const s = $('#stats');
    if (s) s.textContent = `Score: ${state.ok} bon / ${state.ko} faux ‚Ä¢ Item ${state.index+1}/${Math.max(1, state.queue.length)}`;
  }

  // ==== DOM pr√™t ====
  document.addEventListener('DOMContentLoaded', () => {
    const tokenInput = must('#token');
    const saveBtn    = must('#saveToken');
    const clearBtn   = must('#clearToken');
    const modeSelect = must('#mode');
    const levelInput = must('#level');
    const loadBtn    = must('#load');
    const showBtn    = must('#show');
    const successBtn = must('#success');
    const failBtn    = must('#fail');
    const nextBtn    = must('#next');

    // Charger token depuis cookie si pr√©sent
    const cookieToken = getTokenCookie();
    if (cookieToken) tokenInput.value = cookieToken;

    // Afficher/cacher champ niveau
    modeSelect.addEventListener('change', () => {
      levelInput.style.display = (modeSelect.value === 'level') ? 'inline-block' : 'none';
    });

    // Enregistrer token -> cookie
    saveBtn.addEventListener('click', () => {
      const t = (tokenInput.value || '').trim();
      if (!t) return showError('‚ö†Ô∏è Token vide. Va sur WaniKani ‚Üí Settings ‚Üí API Tokens.');
      setTokenCookie(t);
      info('‚úÖ Token enregistr√© dans un cookie.');
    });

    // Effacer le cookie (token)
    clearBtn.addEventListener('click', () => {
      clearTokenCookie();
      info('üßπ Cookie effac√©. Colle √† nouveau ton token si besoin.');
    });

    // Charger items
    loadBtn.addEventListener('click', async () => {
      try {
        resetUI();
        const token = getToken(tokenInput);
        info('Connexion √† WaniKani‚Ä¶');
        const assignments = await fetchAssignments(token, modeSelect, levelInput);
        if (!assignments.length) { info('Aucun kanji pour ce filtre.'); return; }
        const subjects = await fetchSubjects(assignments.map(a => a.data.subject_id), token);
        buildQueue(subjects);
        state.index = 0;
        renderCard();
        info('‚úÖ Pr√™t. Dessine, puis ‚ÄúAfficher le kanji‚Äù.');
      } catch (e) { showError(e); console.error('[Load Error]', e); }
    });

    // Boutons carte
    showBtn.addEventListener('click', () => {
      const k = $('#kanji'); const r = $('#readings');
      if (k) k.style.display = 'block';
      if (r) r.style.display = 'block';
    });
    successBtn.addEventListener('click', () => { state.ok++; updateStats(); nextCard(); });
    failBtn.addEventListener('click', () => { state.ko++; updateStats(); nextCard(); });
    nextBtn.addEventListener('click', () => nextCard());
  });

})();
</script>
</body>
</html>
``
